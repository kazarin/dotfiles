.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "urxvt-background 1"
.TH urxvt-background 1 "2015-01-29" "9.21" "RXVT-UNICODE"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
background \- manage terminal background
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&   urxvt \-\-background\-expr \*(Aqbackground expression\*(Aq
\&         \-\-background\-border
\&         \-\-background\-interval seconds
.Ve
.SH "QUICK AND DIRTY CHEAT SHEET"
.IX Header "QUICK AND DIRTY CHEAT SHEET"
Just load a random jpeg image and tile the background with it without
scaling or anything else:
.PP
.Vb 1
\&   load "/path/to/img.jpg"
.Ve
.PP
The same, but use mirroring/reflection instead of tiling:
.PP
.Vb 1
\&   mirror load "/path/to/img.jpg"
.Ve
.PP
Load an image and scale it to exactly fill the terminal window:
.PP
.Vb 1
\&   scale keep { load "/path/to/img.jpg" }
.Ve
.PP
Implement pseudo-transparency by using a suitably-aligned root pixmap
as window background:
.PP
.Vb 1
\&   rootalign root
.Ve
.PP
Likewise, but keep a blurred copy:
.PP
.Vb 1
\&   rootalign keep { blur 10, root }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This extension manages the terminal background by creating a picture that
is behind the text, replacing the normal background colour.
.PP
It does so by evaluating a Perl expression that \fIcalculates\fR the image on
the fly, for example, by grabbing the root background or loading a file.
.PP
While the full power of Perl is available, the operators have been design
to be as simple as possible.
.PP
For example, to load an image and scale it to the window size, you would
use:
.PP
.Vb 1
\&   urxvt \-\-background\-expr \*(Aqscale keep { load "/path/to/mybg.png" }\*(Aq
.Ve
.PP
Or specified as a X resource:
.PP
.Vb 1
\&   URxvt.background\-expr: scale keep { load "/path/to/mybg.png" }
.Ve
.SH "THEORY OF OPERATION"
.IX Header "THEORY OF OPERATION"
At startup, just before the window is mapped for the first time, the
expression is evaluated and must yield an image. The image is then
extended as necessary to cover the whole terminal window, and is set as a
background pixmap.
.PP
If the image contains an alpha channel, then it will be used as-is in
visuals that support alpha channels (for example, for a compositing
manager). In other visuals, the terminal background colour will be used to
replace any transparency.
.PP
When the expression relies, directly or indirectly, on the window size,
position, the root pixmap, or a timer, then it will be remembered. If not,
then it will be removed.
.PP
If any of the parameters that the expression relies on changes (when the
window is moved or resized, its position or size changes; when the root
pixmap is replaced by another one the root background changes; or when the
timer elapses), then the expression will be evaluated again.
.PP
For example, an expression such as \f(CW\*(C`scale keep { load "$HOME/mybg.png"
}\*(C'\fR scales the image to the window size, so it relies on the window size
and will be reevaluated each time it is changed, but not when it moves for
example. That ensures that the picture always fills the terminal, even
after its size changes.
.SS "\s-1EXPRESSIONS\s0"
.IX Subsection "EXPRESSIONS"
Expressions are normal Perl expressions, in fact, they are Perl blocks \-
which means you could use multiple lines and statements:
.PP
.Vb 8
\&   scale keep {
\&      again 3600;
\&      if (localtime now)[6]) {
\&         return load "$HOME/weekday.png";
\&      } else {
\&         return load "$HOME/sunday.png";
\&      }
\&   }
.Ve
.PP
This inner expression is evaluated once per hour (and whenever the
terminal window is resized). It sets \fIsunday.png\fR as background on
Sundays, and \fIweekday.png\fR on all other days.
.PP
Fortunately, we expect that most expressions will be much simpler, with
little Perl knowledge needed.
.PP
Basically, you always start with a function that \*(L"generates\*(R" an image
object, such as \f(CW\*(C`load\*(C'\fR, which loads an image from disk, or \f(CW\*(C`root\*(C'\fR, which
returns the root window background image:
.PP
.Vb 1
\&   load "$HOME/mypic.png"
.Ve
.PP
The path is usually specified as a quoted string (the exact rules can be
found in the perlop manpage). The \fI\f(CI$HOME\fI\fR at the beginning of the
string is expanded to the home directory.
.PP
Then you prepend one or more modifiers or filtering expressions, such as
\&\f(CW\*(C`scale\*(C'\fR:
.PP
.Vb 1
\&   scale load "$HOME/mypic.png"
.Ve
.PP
Just like a mathematical expression with functions, you should read these
expressions from right to left, as the \f(CW\*(C`load\*(C'\fR is evaluated first, and
its result becomes the argument to the \f(CW\*(C`scale\*(C'\fR function.
.PP
Many operators also allow some parameters preceding the input image
that modify its behaviour. For example, \f(CW\*(C`scale\*(C'\fR without any additional
arguments scales the image to size of the terminal window. If you specify
an additional argument, it uses it as a scale factor (multiply by 100 to
get a percentage):
.PP
.Vb 1
\&   scale 2, load "$HOME/mypic.png"
.Ve
.PP
This enlarges the image by a factor of 2 (200%). As you can see, \f(CW\*(C`scale\*(C'\fR
has now two arguments, the \f(CW200\fR and the \f(CW\*(C`load\*(C'\fR expression, while
\&\f(CW\*(C`load\*(C'\fR only has one argument. Arguments are separated from each other by
commas.
.PP
Scale also accepts two arguments, which are then separate factors for both
horizontal and vertical dimensions. For example, this halves the image
width and doubles the image height:
.PP
.Vb 1
\&   scale 0.5, 2, load "$HOME/mypic.png"
.Ve
.PP
\&\s-1IF\s0 you try out these expressions, you might suffer from some sluggishness,
because each time the terminal is resized, it loads the \s-1PNG\s0 image again
and scales it. Scaling is usually fast (and unavoidable), but loading the
image can be quite time consuming. This is where \f(CW\*(C`keep\*(C'\fR comes in handy:
.PP
.Vb 1
\&   scale 0.5, 2, keep { load "$HOME/mypic.png" }
.Ve
.PP
The \f(CW\*(C`keep\*(C'\fR operator executes all the statements inside the braces only
once, or when it thinks the outcome might change. In other cases it
returns the last value computed by the brace block.
.PP
This means that the \f(CW\*(C`load\*(C'\fR is only executed once, which makes it much
faster, but also means that more memory is being used, because the loaded
image must be kept in memory at all times. In this expression, the
trade-off is likely worth it.
.PP
But back to effects: Other effects than scaling are also readily
available, for example, you can tile the image to fill the whole window,
instead of resizing it:
.PP
.Vb 1
\&   tile keep { load "$HOME/mypic.png" }
.Ve
.PP
In fact, images returned by \f(CW\*(C`load\*(C'\fR are in \f(CW\*(C`tile\*(C'\fR mode by default, so the
\&\f(CW\*(C`tile\*(C'\fR operator is kind of superfluous.
.PP
Another common effect is to mirror the image, so that the same edges
touch:
.PP
.Vb 1
\&   mirror keep { load "$HOME/mypic.png" }
.Ve
.PP
Another common background expression is:
.PP
.Vb 1
\&   rootalign root
.Ve
.PP
This one first takes a snapshot of the screen background image, and then
moves it to the upper left corner of the screen (as opposed to the upper
left corner of the terminal window)\- the result is pseudo-transparency:
the image seems to be static while the window is moved around.
.SS "\s-1COLOUR SPECIFICATIONS\s0"
.IX Subsection "COLOUR SPECIFICATIONS"
Whenever an operator expects a \*(L"colour\*(R", then this can be specified in one
of two ways: Either as string with an X11 colour specification, such as:
.PP
.Vb 4
\&   "red"               # named colour
\&   "#f00"              # simple rgb
\&   "[50]red"           # red with 50% alpha
\&   "TekHVC:300/50/50"  # anything goes
.Ve
.PP
\&\s-1OR\s0 as an array reference with one, three or four components:
.PP
.Vb 3
\&   [0.5]               # 50% gray, 100% alpha
\&   [0.5, 0, 0]         # dark red, no green or blur, 100% alpha
\&   [0.5, 0, 0, 0.7]    # same with explicit 70% alpha
.Ve
.SS "\s-1CACHING AND SENSITIVITY\s0"
.IX Subsection "CACHING AND SENSITIVITY"
Since some operations (such as \f(CW\*(C`load\*(C'\fR and \f(CW\*(C`blur\*(C'\fR) can take a long time,
caching results can be very important for a smooth operation. Caching can
also be useful to reduce memory usage, though, for example, when an image
is cached by \f(CW\*(C`load\*(C'\fR, it could be shared by multiple terminal windows
running inside urxvtd.
.PP
\fI\f(CI\*(C`keep { ... }\*(C'\fI caching\fR
.IX Subsection "keep { ... } caching"
.PP
The most important way to cache expensive operations is to use \f(CW\*(C`keep {
\&... }\*(C'\fR. The \f(CW\*(C`keep\*(C'\fR operator takes a block of multiple statements enclosed
by \f(CW\*(C`{}\*(C'\fR and keeps the return value in memory.
.PP
An expression can be \*(L"sensitive\*(R" to various external events, such as
scaling or moving the window, root background changes and timers. Simply
using an expression (such as \f(CW\*(C`scale\*(C'\fR without parameters) that depends on
certain changing values (called \*(L"variables\*(R"), or using those variables
directly, will make an expression sensitive to these events \- for example,
using \f(CW\*(C`scale\*(C'\fR or \f(CW\*(C`TW\*(C'\fR will make the expression sensitive to the terminal
size, and thus to resizing events.
.PP
When such an event happens, \f(CW\*(C`keep\*(C'\fR will automatically trigger a
reevaluation of the whole expression with the new value of the expression.
.PP
\&\f(CW\*(C`keep\*(C'\fR is most useful for expensive operations, such as \f(CW\*(C`blur\*(C'\fR:
.PP
.Vb 1
\&   rootalign keep { blur 20, root }
.Ve
.PP
This makes a blurred copy of the root background once, and on subsequent
calls, just root-aligns it. Since \f(CW\*(C`blur\*(C'\fR is usually quite slow and
\&\f(CW\*(C`rootalign\*(C'\fR is quite fast, this trades extra memory (for the cached
blurred pixmap) with speed (blur only needs to be redone when root
changes).
.PP
\fI\f(CI\*(C`load\*(C'\fI caching\fR
.IX Subsection "load caching"
.PP
The \f(CW\*(C`load\*(C'\fR operator itself does not keep images in memory, but as long as
the image is still in memory, \f(CW\*(C`load\*(C'\fR will use the in-memory image instead
of loading it freshly from disk.
.PP
That means that this expression:
.PP
.Vb 1
\&   keep { load "$HOME/path..." }
.Ve
.PP
Not only caches the image in memory, other terminal instances that try to
\&\f(CW\*(C`load\*(C'\fR it can reuse that in-memory copy.
.SH "REFERENCE"
.IX Header "REFERENCE"
.SS "\s-1COMMAND LINE SWITCHES\s0"
.IX Subsection "COMMAND LINE SWITCHES"
.IP "\-\-background\-expr perl-expression" 4
.IX Item "--background-expr perl-expression"
Specifies the Perl expression to evaluate.
.IP "\-\-background\-border" 4
.IX Item "--background-border"
By default, the expression creates an image that fills the full window,
overwriting borders and any other areas, such as the scrollbar.
.Sp
Specifying this flag changes the behaviour, so that the image only
replaces the background of the character area.
.IP "\-\-background\-interval seconds" 4
.IX Item "--background-interval seconds"
Since some operations in the underlying XRender extension can effectively
freeze your X\-server for prolonged time, this extension enforces a minimum
time between updates, which is normally about 0.1 seconds.
.Sp
If you want to do updates more often, you can decrease this safety
interval with this switch.
.SS "\s-1PROVIDERS/GENERATORS\s0"
.IX Subsection "PROVIDERS/GENERATORS"
These functions provide an image, by loading it from disk, grabbing it
from the root screen or by simply generating it. They are used as starting
points to get an image you can play with.
.ie n .IP "load $path" 4
.el .IP "load \f(CW$path\fR" 4
.IX Item "load $path"
Loads the image at the given \f(CW$path\fR. The image is set to plane tiling
mode.
.Sp
If the image is already in memory (e.g. because another terminal instance
uses it), then the in-memory copy is returned instead.
.ie n .IP "load_uc $path" 4
.el .IP "load_uc \f(CW$path\fR" 4
.IX Item "load_uc $path"
Load uncached \- same as load, but does not cache the image, which means it
is \fIalways\fR loaded from the filesystem again, even if another copy of it
is in memory at the time.
.IP "root" 4
.IX Item "root"
Returns the root window pixmap, that is, hopefully, the background image
of your screen.
.Sp
This function makes your expression root sensitive, that means it will be
reevaluated when the bg image changes.
.ie n .IP "solid $colour" 4
.el .IP "solid \f(CW$colour\fR" 4
.IX Item "solid $colour"
.PD 0
.ie n .IP "solid $width, $height, $colour" 4
.el .IP "solid \f(CW$width\fR, \f(CW$height\fR, \f(CW$colour\fR" 4
.IX Item "solid $width, $height, $colour"
.PD
Creates a new image and completely fills it with the given colour. The
image is set to tiling mode.
.Sp
If \f(CW$width\fR and \f(CW$height\fR are omitted, it creates a 1x1 image, which is
useful for solid backgrounds or for use in filtering effects.
.ie n .IP "clone $img" 4
.el .IP "clone \f(CW$img\fR" 4
.IX Item "clone $img"
Returns an exact copy of the image. This is useful if you want to have
multiple copies of the same image to apply different effects to.
.ie n .IP "merge $img ..." 4
.el .IP "merge \f(CW$img\fR ..." 4
.IX Item "merge $img ..."
Takes any number of images and merges them together, creating a single
image containing them all. The tiling mode of the first image is used as
the tiling mode of the resulting image.
.Sp
This function is called automatically when an expression returns multiple
images.
.SS "\s-1TILING MODES\s0"
.IX Subsection "TILING MODES"
The following operators modify the tiling mode of an image, that is, the
way that pixels outside the image area are painted when the image is used.
.ie n .IP "tile $img" 4
.el .IP "tile \f(CW$img\fR" 4
.IX Item "tile $img"
Tiles the whole plane with the image and returns this new image \- or in
other words, it returns a copy of the image in plane tiling mode.
.Sp
Example: load an image and tile it over the background, without
resizing. The \f(CW\*(C`tile\*(C'\fR call is superfluous because \f(CW\*(C`load\*(C'\fR already defaults
to tiling mode.
.Sp
.Vb 1
\&   tile load "mybg.png"
.Ve
.ie n .IP "mirror $img" 4
.el .IP "mirror \f(CW$img\fR" 4
.IX Item "mirror $img"
Similar to tile, but reflects the image each time it uses a new copy, so
that top edges always touch top edges, right edges always touch right
edges and so on (with normal tiling, left edges always touch right edges
and top always touch bottom edges).
.Sp
Example: load an image and mirror it over the background, avoiding sharp
edges at the image borders at the expense of mirroring the image itself
.Sp
.Vb 1
\&   mirror load "mybg.png"
.Ve
.ie n .IP "pad $img" 4
.el .IP "pad \f(CW$img\fR" 4
.IX Item "pad $img"
Takes an image and modifies it so that all pixels outside the image area
become transparent. This mode is most useful when you want to place an
image over another image or the background colour while leaving all
background pixels outside the image unchanged.
.Sp
Example: load an image and display it in the upper left corner. The rest
of the space is left \*(L"empty\*(R" (transparent or whatever your compositor does
in alpha mode, else background colour).
.Sp
.Vb 1
\&   pad load "mybg.png"
.Ve
.ie n .IP "extend $img" 4
.el .IP "extend \f(CW$img\fR" 4
.IX Item "extend $img"
Extends the image over the whole plane, using the closest pixel in the
area outside the image. This mode is mostly useful when you use more complex
filtering operations and want the pixels outside the image to have the
same values as the pixels near the edge.
.Sp
Example: just for curiosity, how does this pixel extension stuff work?
.Sp
.Vb 1
\&   extend move 50, 50, load "mybg.png"
.Ve
.SS "\s-1VARIABLE VALUES\s0"
.IX Subsection "VARIABLE VALUES"
The following functions provide variable data such as the terminal window
dimensions. They are not (Perl\-) variables, they just return stuff that
varies. Most of them make your expression sensitive to some events, for
example using \f(CW\*(C`TW\*(C'\fR (terminal width) means your expression is evaluated
again when the terminal is resized.
.IP "\s-1TX\s0" 4
.IX Item "TX"
.PD 0
.IP "\s-1TY\s0" 4
.IX Item "TY"
.PD
Return the X and Y coordinates of the terminal window (the terminal
window is the full window by default, and the character area only when in
border-respect mode).
.Sp
Using these functions makes your expression sensitive to window moves.
.Sp
These functions are mainly useful to align images to the root window.
.Sp
Example: load an image and align it so it looks as if anchored to the
background (that's exactly what \f(CW\*(C`rootalign\*(C'\fR does btw.):
.Sp
.Vb 1
\&   move \-TX, \-TY, keep { load "mybg.png" }
.Ve
.IP "\s-1TW\s0" 4
.IX Item "TW"
.PD 0
.IP "\s-1TH\s0" 4
.IX Item "TH"
.PD
Return the width (\f(CW\*(C`TW\*(C'\fR) and height (\f(CW\*(C`TH\*(C'\fR) of the terminal window (the
terminal window is the full window by default, and the character area only
when in border-respect mode).
.Sp
Using these functions makes your expression sensitive to window resizes.
.Sp
These functions are mainly useful to scale images, or to clip images to
the window size to conserve memory.
.Sp
Example: take the screen background, clip it to the window size, blur it a
bit, align it to the window position and use it as background.
.Sp
.Vb 1
\&   clip move \-TX, \-TY, keep { blur 5, root }
.Ve
.IP "\s-1FOCUS\s0" 4
.IX Item "FOCUS"
Returns a boolean indicating whether the terminal window has keyboard
focus, in which case it returns true.
.Sp
Using this function makes your expression sensitive to focus changes.
.Sp
A common use case is to fade the background image when the terminal loses
focus, often together with the \f(CW\*(C`\-fade\*(C'\fR command line option. In fact,
there is a special function for just that use case: \f(CW\*(C`focus_fade\*(C'\fR.
.Sp
Example: use two entirely different background images, depending on
whether the window has focus.
.Sp
.Vb 1
\&   FOCUS ? keep { load "has_focus.jpg" } : keep { load "no_focus.jpg" }
.Ve
.IP "now" 4
.IX Item "now"
Returns the current time as (fractional) seconds since the epoch.
.Sp
Using this expression does \fInot\fR make your expression sensitive to time,
but the next two functions do.
.ie n .IP "again $seconds" 4
.el .IP "again \f(CW$seconds\fR" 4
.IX Item "again $seconds"
When this function is used the expression will be reevaluated again in
\&\f(CW$seconds\fR seconds.
.Sp
Example: load some image and rotate it according to the time of day (as if it were
the hour pointer of a clock). Update this image every minute.
.Sp
.Vb 2
\&   again 60;
\&   rotate 50, 50, (now % 86400) * \-72 / 8640, scale keep { load "myclock.png" }
.Ve
.ie n .IP "counter $seconds" 4
.el .IP "counter \f(CW$seconds\fR" 4
.IX Item "counter $seconds"
Like \f(CW\*(C`again\*(C'\fR, but also returns an increasing counter value, starting at
0, which might be useful for some simple animation effects.
.SS "\s-1SHAPE CHANGING OPERATORS\s0"
.IX Subsection "SHAPE CHANGING OPERATORS"
The following operators modify the shape, size or position of the image.
.ie n .IP "clip $img" 4
.el .IP "clip \f(CW$img\fR" 4
.IX Item "clip $img"
.PD 0
.ie n .IP "clip $width, $height, $img" 4
.el .IP "clip \f(CW$width\fR, \f(CW$height\fR, \f(CW$img\fR" 4
.IX Item "clip $width, $height, $img"
.ie n .IP "clip $x, $y, $width, $height, $img" 4
.el .IP "clip \f(CW$x\fR, \f(CW$y\fR, \f(CW$width\fR, \f(CW$height\fR, \f(CW$img\fR" 4
.IX Item "clip $x, $y, $width, $height, $img"
.PD
Clips an image to the given rectangle. If the rectangle is outside the
image area (e.g. when \f(CW$x\fR or \f(CW$y\fR are negative) or the rectangle is
larger than the image, then the tiling mode defines how the extra pixels
will be filled.
.Sp
If \f(CW$x\fR and \f(CW$y\fR are missing, then \f(CW0\fR is assumed for both.
.Sp
If \f(CW$width\fR and \f(CW$height\fR are missing, then the window size will be
assumed.
.Sp
Example: load an image, blur it, and clip it to the window size to save
memory.
.Sp
.Vb 1
\&   clip keep { blur 10, load "mybg.png" }
.Ve
.ie n .IP "scale $img" 4
.el .IP "scale \f(CW$img\fR" 4
.IX Item "scale $img"
.PD 0
.ie n .IP "scale $size_factor, $img" 4
.el .IP "scale \f(CW$size_factor\fR, \f(CW$img\fR" 4
.IX Item "scale $size_factor, $img"
.ie n .IP "scale $width_factor, $height_factor, $img" 4
.el .IP "scale \f(CW$width_factor\fR, \f(CW$height_factor\fR, \f(CW$img\fR" 4
.IX Item "scale $width_factor, $height_factor, $img"
.PD
Scales the image by the given factors in horizontal
(\f(CW$width\fR) and vertical (\f(CW$height\fR) direction.
.Sp
If only one factor is given, it is used for both directions.
.Sp
If no factors are given, scales the image to the window size without
keeping aspect.
.ie n .IP "resize $width, $height, $img" 4
.el .IP "resize \f(CW$width\fR, \f(CW$height\fR, \f(CW$img\fR" 4
.IX Item "resize $width, $height, $img"
Resizes the image to exactly \f(CW$width\fR times \f(CW$height\fR pixels.
.ie n .IP "fit $img" 4
.el .IP "fit \f(CW$img\fR" 4
.IX Item "fit $img"
.PD 0
.ie n .IP "fit $width, $height, $img" 4
.el .IP "fit \f(CW$width\fR, \f(CW$height\fR, \f(CW$img\fR" 4
.IX Item "fit $width, $height, $img"
.PD
Fits the image into the given \f(CW$width\fR and \f(CW$height\fR without changing
aspect, or the terminal size. That means it will be shrunk or grown until
the whole image fits into the given area, possibly leaving borders.
.ie n .IP "cover $img" 4
.el .IP "cover \f(CW$img\fR" 4
.IX Item "cover $img"
.PD 0
.ie n .IP "cover $width, $height, $img" 4
.el .IP "cover \f(CW$width\fR, \f(CW$height\fR, \f(CW$img\fR" 4
.IX Item "cover $width, $height, $img"
.PD
Similar to \f(CW\*(C`fit\*(C'\fR, but shrinks or grows until all of the area is covered
by the image, so instead of potentially leaving borders, it will cut off
image data that doesn't fit.
.ie n .IP "move $dx, $dy, $img" 4
.el .IP "move \f(CW$dx\fR, \f(CW$dy\fR, \f(CW$img\fR" 4
.IX Item "move $dx, $dy, $img"
Moves the image by \f(CW$dx\fR pixels in the horizontal, and \f(CW$dy\fR pixels in
the vertical.
.Sp
Example: move the image right by 20 pixels and down by 30.
.Sp
.Vb 1
\&   move 20, 30, ...
.Ve
.ie n .IP "align $xalign, $yalign, $img" 4
.el .IP "align \f(CW$xalign\fR, \f(CW$yalign\fR, \f(CW$img\fR" 4
.IX Item "align $xalign, $yalign, $img"
Aligns the image according to a factor \- \f(CW0\fR means the image is moved to
the left or top edge (for \f(CW$xalign\fR or \f(CW$yalign\fR), \f(CW0.5\fR means it is
exactly centered and \f(CW1\fR means it touches the right or bottom edge.
.Sp
Example: remove any visible border around an image, center it vertically but move
it to the right hand side.
.Sp
.Vb 1
\&   align 1, 0.5, pad $img
.Ve
.ie n .IP "center $img" 4
.el .IP "center \f(CW$img\fR" 4
.IX Item "center $img"
.PD 0
.ie n .IP "center $width, $height, $img" 4
.el .IP "center \f(CW$width\fR, \f(CW$height\fR, \f(CW$img\fR" 4
.IX Item "center $width, $height, $img"
.PD
Centers the image, i.e. the center of the image is moved to the center of
the terminal window (or the box specified by \f(CW$width\fR and \f(CW$height\fR if
given).
.Sp
Example: load an image and center it.
.Sp
.Vb 1
\&  center keep { pad load "mybg.png" }
.Ve
.ie n .IP "rootalign $img" 4
.el .IP "rootalign \f(CW$img\fR" 4
.IX Item "rootalign $img"
Moves the image so that it appears glued to the screen as opposed to the
window. This gives the illusion of a larger area behind the window. It is
exactly equivalent to \f(CW\*(C`move \-TX, \-TY\*(C'\fR, that is, it moves the image to the
top left of the screen.
.Sp
Example: load a background image, put it in mirror mode and root align it.
.Sp
.Vb 1
\&   rootalign keep { mirror load "mybg.png" }
.Ve
.Sp
Example: take the screen background and align it, giving the illusion of
transparency as long as the window isn't in front of other windows.
.Sp
.Vb 1
\&   rootalign root
.Ve
.ie n .IP "rotate $center_x, $center_y, $degrees, $img" 4
.el .IP "rotate \f(CW$center_x\fR, \f(CW$center_y\fR, \f(CW$degrees\fR, \f(CW$img\fR" 4
.IX Item "rotate $center_x, $center_y, $degrees, $img"
Rotates the image clockwise by \f(CW$degrees\fR degrees, around the point at
\&\f(CW$center_x\fR and \f(CW$center_y\fR (specified as factor of image width/height).
.Sp
Example: rotate the image by 90 degrees around its center.
.Sp
.Vb 1
\&   rotate 0.5, 0.5, 90, keep { load "$HOME/mybg.png" }
.Ve
.SS "\s-1COLOUR MODIFICATIONS\s0"
.IX Subsection "COLOUR MODIFICATIONS"
The following operators change the pixels of the image.
.ie n .IP "tint $color, $img" 4
.el .IP "tint \f(CW$color\fR, \f(CW$img\fR" 4
.IX Item "tint $color, $img"
Tints the image in the given colour.
.Sp
Example: tint the image red.
.Sp
.Vb 1
\&   tint "red", load "rgb.png"
.Ve
.Sp
Example: the same, but specify the colour by component.
.Sp
.Vb 1
\&   tint [1, 0, 0], load "rgb.png"
.Ve
.ie n .IP "shade $factor, $img" 4
.el .IP "shade \f(CW$factor\fR, \f(CW$img\fR" 4
.IX Item "shade $factor, $img"
Shade the image by the given factor.
.ie n .IP "contrast $factor, $img" 4
.el .IP "contrast \f(CW$factor\fR, \f(CW$img\fR" 4
.IX Item "contrast $factor, $img"
.PD 0
.ie n .IP "contrast $r, $g, $b, $img" 4
.el .IP "contrast \f(CW$r\fR, \f(CW$g\fR, \f(CW$b\fR, \f(CW$img\fR" 4
.IX Item "contrast $r, $g, $b, $img"
.ie n .IP "contrast $r, $g, $b, $a, $img" 4
.el .IP "contrast \f(CW$r\fR, \f(CW$g\fR, \f(CW$b\fR, \f(CW$a\fR, \f(CW$img\fR" 4
.IX Item "contrast $r, $g, $b, $a, $img"
.PD
Adjusts the \fIcontrast\fR of an image.
.Sp
The first form applies a single \f(CW$factor\fR to red, green and blue, the
second form applies separate factors to each colour channel, and the last
form includes the alpha channel.
.Sp
Values from 0 to 1 lower the contrast, values higher than 1 increase the
contrast.
.Sp
Due to limitations in the underlying XRender extension, lowering contrast
also reduces brightness, while increasing contrast currently also
increases brightness.
.ie n .IP "brightness $bias, $img" 4
.el .IP "brightness \f(CW$bias\fR, \f(CW$img\fR" 4
.IX Item "brightness $bias, $img"
.PD 0
.ie n .IP "brightness $r, $g, $b, $img" 4
.el .IP "brightness \f(CW$r\fR, \f(CW$g\fR, \f(CW$b\fR, \f(CW$img\fR" 4
.IX Item "brightness $r, $g, $b, $img"
.ie n .IP "brightness $r, $g, $b, $a, $img" 4
.el .IP "brightness \f(CW$r\fR, \f(CW$g\fR, \f(CW$b\fR, \f(CW$a\fR, \f(CW$img\fR" 4
.IX Item "brightness $r, $g, $b, $a, $img"
.PD
Adjusts the brightness of an image.
.Sp
The first form applies a single \f(CW$bias\fR to red, green and blue, the
second form applies separate biases to each colour channel, and the last
form includes the alpha channel.
.Sp
Values less than 0 reduce brightness, while values larger than 0 increase
it. Useful range is from \-1 to 1 \- the former results in a black, the
latter in a white picture.
.Sp
Due to idiosyncrasies in the underlying XRender extension, biases less
than zero can be \fIvery\fR slow.
.Sp
You can also try the experimental(!) \f(CW\*(C`muladd\*(C'\fR operator.
.ie n .IP "muladd $mul, $add, $img # \s-1EXPERIMENTAL\s0" 4
.el .IP "muladd \f(CW$mul\fR, \f(CW$add\fR, \f(CW$img\fR # \s-1EXPERIMENTAL\s0" 4
.IX Item "muladd $mul, $add, $img # EXPERIMENTAL"
First multiplies the pixels by \f(CW$mul\fR, then adds \f(CW$add\fR. This can be used
to implement brightness and contrast at the same time, with a wider value
range than contrast and brightness operators.
.Sp
Due to numerous bugs in XRender implementations, it can also introduce a
number of visual artifacts.
.Sp
Example: increase contrast by a factor of \f(CW$c\fR without changing image
brightness too much.
.Sp
.Vb 1
\&   muladd $c, (1 \- $c) * 0.5, $img
.Ve
.ie n .IP "blur $radius, $img" 4
.el .IP "blur \f(CW$radius\fR, \f(CW$img\fR" 4
.IX Item "blur $radius, $img"
.PD 0
.ie n .IP "blur $radius_horz, $radius_vert, $img" 4
.el .IP "blur \f(CW$radius_horz\fR, \f(CW$radius_vert\fR, \f(CW$img\fR" 4
.IX Item "blur $radius_horz, $radius_vert, $img"
.PD
Gaussian-blurs the image with (roughly) \f(CW$radius\fR pixel radius. The radii
can also be specified separately.
.Sp
Blurring is often \fIvery\fR slow, at least compared or other
operators. Larger blur radii are slower than smaller ones, too, so if you
don't want to freeze your screen for long times, start experimenting with
low values for radius (<5).
.ie n .IP "focus_fade $img" 4
.el .IP "focus_fade \f(CW$img\fR" 4
.IX Item "focus_fade $img"
.PD 0
.ie n .IP "focus_fade $factor, $img" 4
.el .IP "focus_fade \f(CW$factor\fR, \f(CW$img\fR" 4
.IX Item "focus_fade $factor, $img"
.ie n .IP "focus_fade $factor, $color, $img" 4
.el .IP "focus_fade \f(CW$factor\fR, \f(CW$color\fR, \f(CW$img\fR" 4
.IX Item "focus_fade $factor, $color, $img"
.PD
Fades the image by the given factor (and colour) when focus is lost (the
same as the \f(CW\*(C`\-fade\*(C'\fR/\f(CW\*(C`\-fadecolor\*(C'\fR command line options, which also supply
the default values for \f(CW\*(C`factor\*(C'\fR and \f(CW$color\fR. Unlike with \f(CW\*(C`\-fade\*(C'\fR, the
\&\f(CW$factor\fR is a real value, not a percentage value (that is, 0..1, not
0..100).
.Sp
Example: do the right thing when focus fading is requested.
.Sp
.Vb 1
\&   focus_fade load "mybg.jpg";
.Ve
.SS "\s-1OTHER STUFF\s0"
.IX Subsection "OTHER STUFF"
Anything that didn't fit any of the other categories, even after applying
force and closing our eyes.
.IP "keep { ... }" 4
.IX Item "keep { ... }"
This operator takes a code block as argument, that is, one or more
statements enclosed by braces.
.Sp
The trick is that this code block is only evaluated when the outcome
changes \- on other calls the \f(CW\*(C`keep\*(C'\fR simply returns the image it computed
previously (yes, it should only be used with images). Or in other words,
\&\f(CW\*(C`keep\*(C'\fR \fIcaches\fR the result of the code block so it doesn't need to be
computed again.
.Sp
This can be extremely useful to avoid redoing slow operations \- for
example, if your background expression takes the root background, blurs it
and then root-aligns it it would have to blur the root background on every
window move or resize.
.Sp
Another example is \f(CW\*(C`load\*(C'\fR, which can be quite slow.
.Sp
In fact, urxvt itself encloses the whole expression in some kind of
\&\f(CW\*(C`keep\*(C'\fR block so it only is reevaluated as required.
.Sp
Putting the blur into a \f(CW\*(C`keep\*(C'\fR block will make sure the blur is only done
once, while the \f(CW\*(C`rootalign\*(C'\fR is still done each time the window moves.
.Sp
.Vb 1
\&   rootalign keep { blur 10, root }
.Ve
.Sp
This leaves the question of how to force reevaluation of the block,
in case the root background changes: If expression inside the block
is sensitive to some event (root background changes, window geometry
changes), then it will be reevaluated automatically as needed.
